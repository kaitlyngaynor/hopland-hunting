---
title: "04b-hmm-3state-parameter-select"
author: "Kaitlyn"
date: "1/20/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

Select the starting parameters for the 3-state HMM, as outlined here:
https://cran.r-project.org/web/packages/moveHMM/vignettes/moveHMM-starting-values.pdf

## Load and clean data

```{r}
library(dplyr)
library(moveHMM)
library(tidyr)
library(ggplot2)
```

Load data & remove outliers.
```{r}
# Load cleaned data
igotu_data <- read.csv("Data/igotu_data_3min_covariates.csv")

# Select columns of interest
igotu_data_fewer <- igotu_data %>% 
    dplyr::select(ID, Party_ID, Longitude, Latitude, DateTime,
                  rugged49.clean, rugged25.clean, rugged9.clean,
                  hq_dist, vegetation.coarser.clean2, view,
                  veg.edges.dist.clean, road.dist.clean,
                  grass_120m, chap_120m, wood_120m)

# prep data for HMM
data_hmm <- moveHMM::prepData(igotu_data_fewer, 
                              type="LL", 
                              coordNames=c("Longitude","Latitude"))

# remove 300 step lengths of 'NA'
data_hmm <- data_hmm %>% 
    drop_na(step) 

# filter out all steps > 15mph
data_hmm <- data_hmm %>% 
    filter(step < 1.207008)
```

Look at step lengths and turn angles.
```{r}
hist(data_hmm$step)
hist(data_hmm$angle)

# determine proportion of step lengths equal to 0
whichzero <- which(data_hmm$step == 0)
length(whichzero)/nrow(data_hmm)
```



## Explore models
```{r}
# Package for parallel computations
library(parallel)
# Create cluster of size ncores
ncores <- detectCores() - 1
cl <- makeCluster(getOption("cl.cores", ncores))

# Export objects needed in parallelised function to cluster 
clusterExport(cl, list("data_hmm", "fitHMM"))

# Number of tries with different starting values
niter <- 100
# Create list of starting values
allPar0 <- lapply(as.list(1:niter), function(x) { 
    # Step length mean
    stepMean0 <- runif(3, min = c(0.0001, 0.05, 0.3), max = c(0.05, 0.3, 1.4))
    # Step length standard deviation
    stepSD0 <- runif(3, min = c(0.0001, 0.05, 0.3), max = c(0.05, 0.3, 1.4))
    # Step length zero mass
    stepZeromass0 <- runif(3, min = 0, max = 1)
    # Turning angle mean
    angleMean0 <- c(0, 0, 0)
    # Turning angle concentration
    angleCon0 <- runif(3, min = c(0.1, 0.5, 1), max = c(0.5, 1, 5))
    # Return vectors of starting values
    stepPar0 <- c(stepMean0, stepSD0, stepZeromass0)
    anglePar0 <- c(angleMean0, angleCon0)
    
    return(list(step = stepPar0, angle = anglePar0))
})
# Fit the niter models in parallel
allm_parallel <- parLapply(cl = cl, X = allPar0, fun = function(par0) { m <- fitHMM(data = data_hmm, nbStates = 3, stepPar0 = par0$step, anglePar0 = par0$angle)
return(m) })

# Extract likelihoods of fitted models
allnllk <- unlist(lapply(allm_parallel, function(m) m$mod$minimum))
allnllk
```

The model converged on the same ending parameter values in 77 of the 100 iterations, indicating numerical stability. 

```{r}
# Index of best fitting model (smallest negative log-likelihood)
whichbest <- which.min(allnllk)
# Best fitting model
mbest <- allm_parallel[[whichbest]]
mbest
plot(mbest)

# export data
saveRDS(allm_parallel, "Data/3state_parallel_parameter_selection.rds")
```

This best model was as follows:

Value of the maximum log-likelihood: -43128.34 

Step length parameters:
----------------------
             state 1     state 2    state 3
mean      0.07300478 0.407273888 0.01452180
sd        0.04568888 0.204495451 0.01085042
zero-mass 0.04702046 0.002801603 0.46953307

Turning angle parameters:
------------------------
                  state 1     state 2    state 3
mean          -0.01188387 -0.01555692 -3.1248968
concentration  1.20947508  1.14251338  0.6127137

Regression coeffs for the transition probabilities:
--------------------------------------------------
             1 -> 2    1 -> 3    2 -> 1   2 -> 3    3 -> 1    3 -> 2
intercept -2.375421 -2.132659 -2.949647 -2.59946 -2.739275 -2.361436

Transition probability matrix:
-----------------------------
           [,1]       [,2]       [,3]
[1,] 0.82542505 0.07674417 0.09783078
[2,] 0.04647155 0.88756983 0.06595862
[3,] 0.05575724 0.08135693 0.86288583

Initial distribution:
--------------------
[1] 0.256253 0.239443 0.504304